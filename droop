#!/usr/bin/env python
"Count election using OpenDroop"

import sys, os, getopt
path = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, os.path.normpath(path))
from module.profile import Profile

#######################################################################
#
#   Count an election
#
#######################################################################

rules = ['wigm_ref']
reportNames = None

usage = """
Usage:

  droop.py [-a arith] [-p prec] [-r report] [-t tiebreak] [-w weaktie] 
                 [-P] [-x reps] rule ballotfile

  -a: override default arithmetic: fixed, qx, rational, integer
  -p: override default precision (in digits)
  -p: override guard precision (in digits, qx only)
  -r: report format: tbd
  -t: strong tie-break method: random
  -w: weak tie-break method: tbd
  -P: profile and send output to profile.out
  -x: specify repeat count (for profiling)

  Runs an election for the given election rule and ballot file.
  Results are printed to stdout.
  The following methods are available:
  %s
""" % ", ".join(rules)

# Parse the command line.
try:
    (opts, args) = getopt.getopt(sys.argv[1:], "Pa:p:r:t:w:x:")
except getopt.GetoptError, err:
    print str(err) # will print something like "option -q not recognized"
    print usage
    sys.exit(1)

doProfile = False
reps = 1
prec = None
guard = None
arithmetic = None

for o, a in opts:
    if o == "-r":
          if a in reportNames:
              reportformat = a
          else:
              print "Unrecognized report format '%s'" % a
              print usage
              sys.exit(1)
    if o == "-a":
          if a in ["fixed", "qx", "rational", "integer"]:
              arithmetic = a
          else:
              print "Unrecognized arithmetic '%s'" % a
              print usage
              sys.exit(1)
    if o == "-p":
          prec = int(a)
    if o == "-g":
          guard = int(a)
    if o == "-t":
          if a in ["random", "alpha", "index"]:
              strongTieBreakMethod = a
          else:
              print "Unrecognized tie-break method '%s'" % a
              print usage
              sys.exit(1)
    if o == "-w":
          if a in ["strong", "forward", "backward"]:
              weakTieBreakMethod = a
          else:
              print "Unrecognized weak tie-break method '%s'" % a
              print usage
              sys.exit(1)
    if o == "-P":
          import cProfile
          import pstats
          doProfile = True
          profilefile = "profile.out"
    if o == "-x":
          reps = int(a)
    if o == "=h":
          print usage
          sys.exit(0)

if len(args) == 1:
    ruleName = 'wigm_ref'  # handy default for testing
    bltPath = args[0]
elif len(args) != 2:
    if len(args) < 2:
          print "Specify rule and ballot file"
    else:
          print "Too many arguments"
    print usage
    sys.exit(1)
else:
    ruleName = args[0]
    bltPath = args[1]

if ruleName == 'wigm_ref':
    import rule.wigm_ref
    Rule = rule.wigm_ref.Rule
elif ruleName == 'wigm_tst':
    import rule.wigm_tst
    Rule = rule.wigm_tst.Rule
else:
    print "Unrecognized rule '%s'" % ruleName
    print usage
    sys.exit(1)

def doElection(reps=1):
    "run election with repeat count for profiling"
    e = Rule.init(arithmetic=arithmetic, precision=prec, guard=guard)
    profile = Profile(e, None)
    if not profile.bltPath(bltPath):
        sys.exit(1)  # bad ballot file
    for i in xrange(reps):
        Rule.count(e)    # repeat for profiling
    return e

if doProfile:
    cProfile.run('e = doElection(reps)', profilefile)
else:
    e = doElection()

print e.report()    # election report

if doProfile:
    p = pstats.Stats(profilefile)
    p.strip_dirs().sort_stats('time').print_stats(50)
